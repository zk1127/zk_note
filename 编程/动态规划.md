## 动态规划

#### 背包问题

- 如果求组合数就是外层for循环遍历物品，内层for遍历背包。

- 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

- 01背包

  - ```java
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    ```

- 完全背包

  - ```java
    // 先遍历物品，再遍历背包
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    ```

- 区别在于完全背包的内循环是正序，01是逆序，正序可以使得物品被多次放入背包

- 背包的组合和排列问题

  - 组合

  - ```java
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
            dp[j] += dp[j - coins[i]];
        }
    }
    ```

    

  - 排列

  - ```java
    for (int j = 0; j <= amount; j++) { // 遍历背包容量
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
        }
    }
    ```

  - 排列为先遍历背包，在遍历物品，组合则相反。排列这样遍历可以使得{1，4}和{4，1}这样的结果同时被遍历

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

- 动态规划：本质上思路与连续和最大的数组一致(f[n - 1] +nums[i] 和nums[i] 之间取最大)，乘积需要注意的是，考虑正数最大和负数最小，所以其存在三种情况

- dp[i] 表示以i结尾的数组中乘积最大的值

- ```java
  public int maxProduct(int[] nums) {
      int n = nums.length;
      int[] maxF = new int[n];
      int[] minF = new int[n];
      maxF[0] = nums[0];
      minF[0] = nums[0];
      int ans = maxF[0];
      for (int i = 1; i < n; i++) {
          maxF[i] = Math.max(maxF[i - 1] * nums[i], minF[i - 1] * nums[i]);
          maxF[i] = Math.max(maxF[i], nums[i]);
          minF[i] = Math.min(minF[i - 1] * nums[i], maxF[i - 1] * nums[i]);
          minF[i] = Math.min(minF[i], nums[i]);
          ans = Math.max(ans, maxF[i]);
      }    
      return ans;
  }
  ```

#### [1567. 乘积为正数的最长子数组长度](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)

- 动态规划：$positive[i]$ 表示以下标 $i$结尾的乘积为正数的最长子数组长度，$negative[i] $表示乘积为负数的最长子数组长度。

- ```java
  public int getMaxLen(int[] nums) {
      int n = nums.length;
      int[] pos = new int[n];
      int[] neg = new int[n];
      if (nums[0] > 0) {
          pos[0] = 1;
      }else if (nums[0] < 0) {
          neg[0] = 1;
      }
      int ans = pos[0];
      for (int i = 1; i < n; i++) {
          if (nums[i] > 0) {
              pos[i] = pos[i - 1] + 1;
              neg[i] = neg[i - 1] > 0 ? neg[i - 1] + 1: 0;
          }else if(nums[i] < 0){
              pos[i] = neg[i - 1] > 0 ? neg[i - 1] + 1: 0;
              neg[i] = pos[i - 1] + 1; 
          } else{
              pos[i] = 0;
              neg[i] = 0;
          }
          ans = Math.max(ans, pos[i]);
      }
      return ans;
  }
  ```

  

