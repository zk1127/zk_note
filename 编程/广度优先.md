

## 广度优先

#### dijkstra算法

- 通用版本,需要一个辅助类要管理距离状态

- ```java
  class State{
      int id;
      int distToStart;
  
      public State(int id, int distToStart){
          this.id = id;
          this.distToStart = distToStart;
      }
  }
  ```

- 使用优先级队列来优化策略

- ```java
      public int[] dijkstra(List<int[]>[] graph, int start){
          int[] distTo = new int[graph.length];
          Arrays.fill(distTo, Integer.MAX_VALUE);
  
          distTo[start] = 0;
          Queue<State> pq = new PriorityQueue<>((o1,o2)->(o1.distToStart-o2.distToStart));
          pq.offer(new State(start, 0));
  
          while (!pq.isEmpty()){
              State curState = pq.poll();
              int id = curState.id;
              int distToStart = curState.distToStart;
  
              if (distToStart > distTo[id]){
                  continue;
              }
              for (int[] p: graph[id]){
                  int nextID = p[0];
                  int distToNext = distTo[id] + p[1];
                  if (distTo[nextID] > distToNext){
                      distTo[nextID] = distToNext;
                      pq.offer(new State(nextID, distToNext));
                  }
              }
          }
          return distTo;
      }
  ```

  #### 网络延迟时间

- leetcode [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

- 计算每个点到起点的延迟时间,统计极大值,如果有MAX_VALUE,则返回-1

- ```java
      public int networkDelayTime(int[][] times, int n, int k) {
          List<int[]>[] graph = new ArrayList[n + 1];
          for (int i = 1; i <= n; i++){
              graph[i] = new ArrayList<>();
          }
  
          for (int[] time: times){
              int from = time[0];
              int to = time[1];
              int dist = time[2];
              graph[from].add(new int[]{to, dist});
          }
  
          int[] distTo = dijkstra(graph, k);
          int ans = 0;
          for (int i = 1; i <= n; i++){
              // System.out.println(di);
              if (distTo[i] == Integer.MAX_VALUE){
                  return -1;
              }
              ans = Math.max(ans, distTo[i]);
          }
          return ans;
      }
  ```

  

