## 单调栈

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

- 双指针，对于任意一个柱子，左右两边**寻找最大的一个**，然后就能知道在这个柱子里最多能蓄水多少

- ```java
  public int trap(int[] height) {
      int n = height.length;
      int ans = 0;
      for (int i = 0; i < n; i++){
          int left = i;
          int leftTop = height[i];
          for (;left >= 0; left--){
              if (height[left] > leftTop) leftTop = height[left];
          }
          int right = i;
          int rightTop = height[i];
          for (;right < n; right++){
              if (height[right] > rightTop) rightTop = height[right];
          }
          int h = Math.min(leftTop, rightTop) - height[i];
          ans += h;
      }
      return ans;
  }
  ```

- 动态规划：双指针的改进版，因为对于每个i寻找左右两边最大的柱子这个过程是会重复搜索，可以事先一次找好，重复利用

- ```java
  public int trap(int[] height) {
      int n = height.length;
      int ans = 0;
      int[] leftMax = new int[n];
      int[] rightMax = new int[n];
      leftMax[0] = height[0];
      rightMax[n - 1] = height[n - 1];
      for (int i = 1; i < n; i++){
          leftMax[i] = Math.max(height[i], leftMax[i - 1]);
      }
      for (int i = n - 2; i >= 0; i--){
          rightMax[i] = Math.max(height[i], rightMax[i + 1]);
      }
      for (int i = 0; i < n; i++){
          int left = leftMax[i];
          int right = rightMax[i];
          int h = Math.min(left, right) - height[i];
          ans += h;
      }
      return ans;
  }
  ```

- 单调栈，单调递减入栈，一旦遇到比栈顶大，说明出现凹槽，可以积蓄雨水

- ```java
  public int trap(int[] height) {
      int n = height.length;
      int ans = 0;
      if (n <= 1) return ans;
      Stack<Integer> stack = new Stack<>();
      stack.push(0);
      for (int i = 1; i < n; i++){
          while(!stack.isEmpty() && height[i] > height[stack.peek()]){
              int mid = stack.pop();
              if (stack.isEmpty()) break;//第一根柱子无法蓄水
              int h = Math.min(height[i], height[stack.peek()]) - height[mid];
              int w = i - stack.peek() - 1;
              ans += w * h;
          }
          stack.push(i);
      }
      return ans;
  }
  ```

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

- 双指针：对于每个i柱，可以左右扩展直至比h[i]低，就能找到以其h[i] 为高的最大面积矩形

- ```java
  public int largestRectangleArea(int[] heights) {
      int n = heights.length;
      int ans = 0;
      for (int i = 0; i < n; i++){
          int h = heights[i];
          int left = i - 1;
          for (left = i - 1; left >= 0; left--){
              if (heights[left] < heights[i]) break;
          }
          int right = i + 1;
          for(; right < n; right++){
              if (heights[right] < heights[i]) break;
          }
          int w = right - left - 1;
          ans = Math.max(ans, w * h);
      }
      return ans;
  }
  ```

- 单调栈：可以发现双指针是找到比他小的柱子就可以停止探索，这符合单调栈的性质

- 这里为了解决第一根柱子和最后一根柱子的面积问题，可以使用哨兵节点

- ```java
  public int largestRectangleArea(int[] heights) {
      int n = heights.length;
      int ans = 0;
      int[] newHeight = new int[n + 2];
      for (int i = 1; i <= n; i++) newHeight[i] = heights[i - 1];
      Stack<Integer> stack = new Stack<>();
      stack.push(0);
      for (int i = 1; i <= n + 1; i++){
          while (newHeight[stack.peek()] >  newHeight[i]){
              int p = stack.pop();
              int h = newHeight[p];
              int w = i - stack.peek() - 1;
              ans = Math.max(ans, w * h);
          }
          stack.push(i);
      }
      return ans;
  }
  ```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

- 暴力遍历，从后往前遍历

- ```java
  public int[] dailyTemperatures(int[] T) {
      int[] res = new int[T.length];
      res[T.length - 1] = 0;
      for(int i = T.length - 2;i >= 0;i--){
          for(int j = i + 1;j < T.length;j += res[j]){// 这里j可以直接跳到比j大的位置
              if(T[i] < T[j]){
                  res[i] = j - i;
                  break;
              }else if(res[j] == 0){
                  res[i] = 0;
                  break;
              }
          }
      }
      return res;
  }
  ```

- 单调栈，目标是找到右边第一个比当前大的值，符合单调栈的需求

- ```java
  public int[] dailyTemperatures(int[] T) {
      int n = T.length;
      int[] res = new int[n];
      Stack<Integer> stack = new Stack<>();
      stack.push(0);
      for (int i = 1; i < n; i++){
          while(!stack.isEmpty() && T[stack.peek()] < T[i]){
              int t = stack.pop();
              res[t] = i - t;
          }
          stack.push(i);
      }
      return res;
  }
  ```

  

#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

- 暴力法，找到这个元素在nums2的位置，再从右边找到比他大的元素

- ```java
  public int[] nextGreaterElement(int[] nums1, int[] nums2) {
      int[] res = new int[nums1.length];
      Arrays.fill(res, -1);
      for (int i = 0; i < nums1.length; i++){
          boolean flag = false;
          for (int j = 0; j < nums2.length; j++){
              if (nums2[j] == nums1[i]){
                  flag = true;
              }
              if (flag && nums2[j] > nums1[i]){
                  res[i] = nums2[j];
                  break;
              }
          }
      }
      return res;
  }
  ```

- 单调栈，同样是找到右侧第一个比自己大的元素

- ```java
  public int[] nextGreaterElement(int[] nums1, int[] nums2) {
      Map<Integer, Integer> map = new HashMap<>();
      Stack<Integer> stack = new Stack<>();
      stack.push(0);
      for (int i = 1; i < nums2.length; i++){
          while(!stack.isEmpty() && nums2[stack.peek()] < nums2[i]){
              int t = stack.pop();
              map.put(nums2[t], nums2[i]);
          }
          stack.push(i);
      }
      int[] res = new int[nums1.length];
      for (int i = 0; i < nums1.length; i++){
          if (!map.containsKey(nums1[i])){
              res[i] = -1;
          }else{
              res[i] = map.get(nums1[i]);
          }
      }
      return res;
  }
  ```


#### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

- 单调栈，对于字母s[i], 如果遇到比当前字母字典序小的字母，就考虑在之后是否会有相同s[i]，如果有，则不需要保存当前字母，所以符合单调栈前提

- ```java
      public String removeDuplicateLetters(String s) {
          int len = s.length();
          if (len <= 1) return s;
          int[] lastIdx = new int[26];
          for (int i = 0; i < len; i++){
              lastIdx[s.charAt(i) - 'a'] = i; // 记录每个字母最后存在的索引
          }
          boolean[] visited = new boolean[26];
          Stack<Character> stack = new Stack<>();
          for (int i = 0; i < len; i++){
              char c = s.charAt(i);
              if (visited[c - 'a']) continue; //如果当前字母已经在栈内，跳过
              while(!stack.isEmpty() && c < stack.peek() && lastIdx[stack.peek() - 'a'] > i) {
                  char temp = stack.pop();
                  visited[temp - 'a'] = false;
              }
              stack.push(c);
              visited[c - 'a'] = true;
          }
          StringBuilder sb = new StringBuilder();
          while (!stack.isEmpty()) {
              sb.append(stack.pop());
          }
          return sb.reverse().toString();
      }
  ```

#### [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

- 单调栈，考虑到数字的单调性质，如果出现"432"这种情况，就应该移除4才能得到最小的数，因此目标是找到右侧比自身小的数字

- ```java
  public String removeKdigits(String num, int k) {
      Deque<Integer> queue = new ArrayDeque(); //双端队列是为了后面逆序得到数字
      for (int i = 0; i < num.length(); i++){
          while (!queue.isEmpty() && queue.peekLast() > (num.charAt(i) - '0') && k > 0){
              queue.pollLast();
              k--;
          }
          queue.offerLast(num.charAt(i) - '0');
      }
      while (k > 0) {
          queue.pollLast();
          k--;
      }
      StringBuilder sb = new StringBuilder();
      boolean leadingZero = true;
      while (!queue.isEmpty()) {
          int digit = queue.pollFirst();
          if (leadingZero && digit == 0) {
              continue;
          }
          leadingZero = false;
          sb.append(digit);
      }
      return sb.length() == 0 ? "0" : sb.toString();
  }
  ```

#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

- 优先队列，同时存储对象为{nums[i], i},按照nums[i]进行比较，一旦堆顶值得index < i - k, 说明堆顶不在当前i得滑动窗口中，需要出队(这里需要循环判断)

- 时间复杂度: O(nlogn) ,空间复杂度: O(n)

  ```java
  public int[] maxSlidingWindow(int[] nums, int k) {
      PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> (o2[0] - o1[0]));
      for (int i = 0; i < k; i++) {
          pq.offer(new int[]{nums[i], i});
      }
      int[] res = new int[nums.length - k + 1];
      res[0] = pq.peek()[0];
      for (int i = k; i < nums.length; i++) {
          pq.offer(new int[]{nums[i], i});
          while (!pq.isEmpty() && pq.peek()[1] <= i - k) { // 判断是否在窗口内
              pq.poll();
          }
          res[i - k + 1] = pq.peek()[0];
      }
      return res;
  }
  ```

  - 单调栈，这里其实仍是记录i左边最大的值，只不过需要控制这个索引要大于i - k， 需要一个递减栈

  - 这里会使用双端队列是因为，记录得结果在左边，需要从左边删除

  - ```java
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new LinkedList<>();
        // 单调栈
        for (int i = 0; i < k; i++) {
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.offer(i);
        }
        int[] res = new int[nums.length - k + 1];
        res[0] = nums[deque.peekFirst()];
        for (int i = k; i < nums.length; i++) {
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.offer(i);
            if (deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            res[i -k + 1] = nums[deque.peekFirst()];
        }
        return res;
    }
    ```

    - 精简版

    - ```java
      public int[] maxSlidingWindow(int[] nums, int k) {
          Deque<Integer> deque = new LinkedList<>();
          // 单调栈
          int[] res = new int[nums.length - k + 1];
          // res[0] = nums[deque.peekFirst()];
          for (int i = 0; i < nums.length; i++) {
              while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                  deque.pollLast();
              }
              deque.offer(i);
              if (i < k - 1) continue;
              if (deque.peekFirst() <= i - k) {
                  deque.pollFirst();
              }
              res[i - k + 1] = nums[deque.peekFirst()];
          }
          return res;
      }
      ```

      
