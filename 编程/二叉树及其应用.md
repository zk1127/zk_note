## 二叉树及其应用

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- 思路：递归，后序遍历思想

- ```java
  public TreeNode invertTree(TreeNode root) {
      if(root == null) return root;
      TreeNode left = invertTree(root.left);
      TreeNode right = invertTree(root.right);
      root.left = right;
      root.right = left;
      return root;
  }
  ```

  

- 思路：层序遍历

- ```java
  public TreeNode invertTree(TreeNode root) {
      if(root == null) return root;
      Queue<TreeNode> queue = new ArrayDeque<>();
      queue.offer(root);
      while (!queue.isEmpty()){
          TreeNode node = queue.poll();
          TreeNode temp = node.left;
          node.left = node.right;
          node.right = temp;
          if (node.left != null){
              queue.offer(node.left);
          }
          if (node.right != null){
              queue.offer(node.right);
          }
      }
      return root;
  }
  ```

  #### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

- 思路：递归思想，判断左右子树是否对称，以及镜面对称的节点是否对称

- ```java
  public boolean isSymmetric(TreeNode root) {
      if (root == null) return true;
      return isSymmetric(root, root);
  }
  
  public boolean isSymmetric(TreeNode left, TreeNode right){
      if (left == null && right == null) return true;
      if (left == null || right == null) return false;
      return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left); //后两个是判断镜像
  }
  ```


- 迭代法：层序遍历，控制加入顺序，使得镜像对称的先后加入，同时队列操作出队时做判断

- 这里队列实现必须使用LinkedList，使用ArrayDeque无法加入null节点

- ```java
  public boolean isSymmetric(TreeNode root) {
      if (root == null) return true;
      if (root.left == null && root.right == null) return true;
      if (root.left == null || root.right == null) return false;
      TreeNode left = root.left;
      TreeNode right = root.right;
      Queue<TreeNode> queue = new LinkedList<>();
      queue.offer(left);
      queue.offer(right);
      while (!queue.isEmpty()){
          TreeNode node1 = queue.poll();
          TreeNode node2 = queue.poll();
          if (node1 == null && node2 == null) continue;
          if (node1 == null || node2 == null) return false;
          if (node1.val != node2.val) return false;
          queue.offer(node1.left);
          queue.offer(node2.right);
          queue.offer(node1.right);
          queue.offer(node2.left);
      }
      return true;
  }
  ```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

- 思路，与最大深度不同的是，这里要考虑的是到叶子节点的最小深度，如果左子树为空，并不是叶子节点，此时深度会是0，但是不是想要的答案

- ```java
      public int minDepth(TreeNode root) {
          if (root == null) return 0;
          int left = minDepth(root.left);
          int right = minDepth(root.right);
          if (root.left == null && root.right != null){
              return 1 + right;
          }
          if (root.left != null && root.right == null){
              return 1 + left;
          }
          return 1 + Math.min(left, right);
      }
  ```

- 思路：迭代解法，**考虑深度可以使用层序遍历**

- ```java
  public int minDepth(TreeNode root) {
      if (root == null) return 0;
      Queue<TreeNode> queue = new LinkedList<>();
      queue.offer(root);
      int ans = 0;
      while (!queue.isEmpty()){
          int size = queue.size();
          ans += 1;
          for (int i = 0; i < size; i++){
              TreeNode node = queue.poll();
              if (node.left == null && node.right == null) {
                  return ans;
              }
              if (node.left != null) queue.offer(node.left);
              if (node.right != null) queue.offer(node.right);
          }
      }
      return ans;
  }
  ```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

- 深度优先遍历

```java
List<String> result = new ArrayList<>();
public List<String> binaryTreePaths(TreeNode root) {
    if (root == null) return result;
    backtrack(root, "");
    return result;
}

public void backtrack(TreeNode root, String s){
    s = s + root.val;
    if (root.left == null && root.right == null){
        result.add(s);
        return;
    }
    if (root.left != null) backtrack(root.left, s + "->");
    if (root.right != null) backtrack(root.right, s + "->");
}
```

#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

- 思路：递归，每次判断是否是左子叶，如果是的话就加上左子叶的值

- ```java
  int ans = 0;
  public int sumOfLeftLeaves(TreeNode root) {
      if (root == null) return 0;
      if (root.left != null && root.left.left == null && root.left.right == null) 
          ans += root.left.val;
      if (root.left != null)  sumOfLeftLeaves(root.left);
      if (root.right != null) sumOfLeftLeaves(root.right);
      return ans;
  }
  ```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

- 思路：回溯，到达叶节点记录一次结果

- ```java
  public boolean hasPathSum(TreeNode root, int sum) {
      if (root == null) return false;
      return backtrack(root, sum - root.val);
  }
  
  public boolean backtrack(TreeNode root, int sum){
      if (root.left == null && root.right == null && sum == 0) return true;
      if (root.left == null && root.right == null) return false;
      if (root.left != null){
          sum -= root.left.val;
          if(backtrack(root.left, sum)) return true;
          sum += root.left.val;
      }
      if (root.right != null){
          sum -= root.right.val;
          if(backtrack(root.right, sum)) return true;
          sum += root.right.val;
      }
      return false;
  }
  ```

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

- 思路：跟上题一样，回溯思想

- ```java
  List<List<Integer>> result = new ArrayList<>();
  public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
      if (root == null) return result;
      ArrayList<Integer> list = new ArrayList<>();
      list.add(root.val);
      backtrack(root, targetSum - root.val, list);
      return result;
  }
  
  public void backtrack(TreeNode root, int curSum, ArrayList<Integer> list){
      if (root.left == null && root.right == null && curSum == 0) {
          result.add(new ArrayList<>(list));
          return;
      }
      if (root.left == null && root.right == null && curSum != 0) return ;
      if (root.left != null){
          list.add(root.left.val);
          curSum -= root.left.val;
          backtrack(root.left,curSum, list);
          curSum += root.left.val;
          list.remove(list.size() - 1);
      }
      if (root.right != null){
          list.add(root.right.val);
          curSum -= root.right.val;
          backtrack(root.right, curSum, list);
          curSum += root.right.val;
          list.remove(list.size() - 1);
      }
  }
  ```

  #### 98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

- 二叉搜索树的特点是中序遍历是有序数组，naive的方法是将其遍历到数组中去判断有序

- 也可以在遍历过程中比较是否有序

- ```java
  TreeNode pre = null;
  public boolean isValidBST(TreeNode root) {
      if (root == null) return true;
      boolean left = isValidBST(root.left);
      if (pre != null && pre.val >= root.val)
          return false;
      pre = root;
      boolean right = isValidBST(root.right);
      return left && right;
  }
  ```

- 迭代

- ```java
  public boolean isValidBST(TreeNode root) {
      if (root == null) return true;
      TreeNode pre = null;
      Stack<TreeNode> stack = new Stack<>();
      while(!stack.isEmpty() || root != null) {
          if (root != null){
              stack.push(root);
              root = root.left;
          }else{
              TreeNode node = stack.pop();
              if (pre != null && node.val <= pre.val) {
                  return false;
              }
              pre = node;
              root = node.right;
          }
      }
      return true;
  }
  ```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

- 思路：后序遍历，自底向上

- ```java
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (root == p ||| root = q || root == null) return root;
      TreeNode left = lowestCommonAncestor(root.left, p, q);
      TreeNode right = lowestCommonAncestor(root.right, p, q);
      if (left != null && right != null){ //如果左右都存在，则当前节点是最近祖先
          return root;
      }
      if (left != null)
          return root.right;
      return root.left;
  }
  ```

#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

- 删除二叉搜索树的节点，需要分情况讨论

- (1.当前节点为空直接返回，2. 当前节点为所求值，如果左节点为空，直接返回右节点，右节点为空类似，3. 如果左右节点都不为空，就把左节点放到右节点的最深的左节点下)

- ```java
  public TreeNode deleteNode(TreeNode root, int key) {
      if (root == null) return root;
      if (root.val == key) {
          if (root.left == null)  return root.right;
          if (root.right == null) return root.left;
          else if (root.left != null && root.right != null){
              TreeNode node = root.right;
              while (node.left != null){
                  node = node.left;
              }
              node.left = root.left;
              return root.right;
          }
      }
      if (root.val > key) root.left = deleteNode(root.left, key);
      if (root.val < key) root.right = deleteNode(root.right, key);
      return root;
  }
  ```

