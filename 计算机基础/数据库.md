

### 数据库

##### 数据库事务特征

数据库事务特征，即 ACID：

> A Atomicity 原子性

事务是一个原子性质的操作单元，事务里面的对数据库的操作要么都执行，要么都不执行

> C Consistent 一致性

在事务开始之前和完成之后，数据都必须保持一致状态，必须保证数据库的完整性。也就是说，数据必须符合数据库的规则。

> I Isolation 隔离性

数据库允许多个并发事务同事对数据进行操作，隔离性保证各个事务相互独立，事务处理时的中间状态对其它事务是不可见的，以此防止出现数据不一致状态。可通过事务隔离级别设置：包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）

> D Durable 持久性

一个事务处理结束后，其对数据库的修改就是永久性的，即使系统故障也不会丢失。

##### MySQL 数据隔离级别

首先 MySQL 里有四个隔离级别：Read uncommttied（可以读取未提交数据）、Read committed（可以读取已提交数据）、Repeatable read（可重复读）、Serializable（可串行化）。

在 InnoDB 中，默认为 Repeatable 级别，InnoDB 中使用一种被称为 next-key locking 的策略来避免幻读（phantom）现象的产生。

使用 `select @@tx_isolation;` 可以查看 MySQL 默认的事务隔离级别。

不同的事务隔离级别会导致不同的问题：

![15352624354970.jpg](https://user-gold-cdn.xitu.io/2018/8/27/1657927364adccc5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

###### 脏读(Dirty Read)：读到了事务未提交的数据

- 当一个事务正在访问数据并且对数据进行了修改,而这种修改还没有提交到数据库中,这时另外一个事务也访问了这个数据,然后使用了这个数据。因为这个数据是还没有提交的数据,那么另外一个事务读到的这个数据是“脏数据”,依据“脏数据”所做的操作可能是不正确的。

###### 丢失修改(Lost to modify)

- 指在一个事务读取一个数据时,另外一个事务也访问了该数据,那么在第一个事务中修改了这个数据后,第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失,因此称为丢失修改。 例如:事务1读取某表中的数据A=20,事务2也读取A=20,事务1修改A=A-1,事务2也修改A=A-1,最终结果A=19,事务1的修改被丢失。

###### 不可重复读(Unrepeatableread)

- 不可重复读是指在事务1内，读取了一个数据，事务1还没有结束时，事务2也访问了这个数据，修改了这个数据，并提交。紧接着，事务1又读这个数据。由于事务2的修改，那么事务1两次读到的的数据可能是不一样的，因此称为是不可重复读

###### **幻读** 

- 幻读，指的是当某个事务在读取**某个范围**内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。

##### 锁机制与InnoDB锁算法
- MyISAM和InnoDB存储引擎使用的锁:
  - MyISAM采用表级锁(table-level locking)。
  - InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

- 表级锁和行级锁对比:
  - 表级锁: MySQL中锁定 粒度最大 的一种锁,对当前操作的整张表加锁,实现简单,资源消耗也比较少,加锁快,不会出现死锁。其锁定粒度最大,触发锁冲突的概率最高,并发度最低,MyISAM和 InnoDB引擎都支持表级锁。
  - 行级锁: MySQL中锁定 粒度最小 的一种锁,只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小,并发度高,但加锁的开销也最大,加锁慢,会出现死锁。